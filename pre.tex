\documentclass[UTF-8]{ctexbeamer}
\usecolortheme{seahorse}

\usepackage{multimedia}
\usepackage{listings}
\usepackage{minted}
\usepackage[normalem]{ulem}

\title{How NOT to Rust}

\author{å–µå–µ}
\date{2021.10}

\begin{document}
\begin{frame}
  \titlepage
  \begin{center}
    \includegraphics[width=.1\textwidth]{assets/float.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{How NOT to Rust}

  æœ¬æ¥æƒ³ç”¨çš„æ ‡é¢˜æ˜¯ \texttt{A Brief, Incomplete, and Mostly Wrong History of Rust}\footnote{\url{http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html}}ã€‚

  \pause
  \vspace{1em}

  ä½†æ˜¯å–µå–µå†™ Slide æ¯«æ— çµæ„Ÿ\dots

  \begin{figure}
    \includegraphics<2>[width=0.25\textwidth]{assets/avatar.jpg}
    \includegraphics<3>[width=0.5\textwidth]{assets/avatarWD40.png}
    \only<2>{\caption{å‘¼å‘¼å–µå–µ}}
    \only<3>{\caption{ç²¾ç¥å–µå–µï¼ï¼}}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{How NOT to Rust}

  æ¥èŠèŠ Rust çš„å†å²ã€‚ï¼ˆå…¶å®å¤§å¤šæ•°æ˜¯å–µå–µçš„ Rantï¼‰

  \pause

  è¿™ä¸ª Talk åŒ…æ‹¬ï¼š
  \begin{itemize}
    \item Rust Overviewï¼
    \item Rust çš„å„ç§ Joke
  \end{itemize}

  è¿™ä¸ª Talk ä¸åŒ…æ‹¬ï¼š
  \begin{itemize}
    \item Rust è¯¦ç»†å…¥é—¨ï¼Œè¯·æŸ¥çœ‹ The Rust Programming Language
    \item Rust è¯¦ç»†è¯­ä¹‰ï¼Œè¯·æŸ¥çœ‹ The Rust Language Reference
    \item è®²è€…å­˜åœ¨ Rust æ·±åˆ»çŸ¥è¯†çš„ä»»ä½•å¯èƒ½ã€‚
  \end{itemize}

  \pause

  å–µå–µåˆšåˆšå…¥é—¨ Rustï¼Œè¯·çˆ±æŠ¤å–µå–µï¼
\end{frame}

\begin{frame}
  \frametitle{å¿«é€Ÿ Rust å…¥é—¨}

  Rust å’Œ \texttt{C(|++), Java(|Script), Python, LISP, \dots} æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ

  \pause
  \vspace{1em}

  \begin{itemize}
    \item Algebraic Data Types
    \item \texttt{crate} and \texttt{module}
    \item Polymorphism: Generic + Trait
    \item (The dreaded) Lifetime / \texttt{borrowck}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ADT: Algebraic Data Types}

  \begin{minted}{rust}
// KV DB, Client -> Server conn payload
enum KVPayload {
  Close,
  Get(String),
  Put {
    key: String,
    value: String,
    expire: Datetime,
  },
}
  \end{minted}

  \pause
  \vspace{1em}
  Disjoint sum over products!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Module-level encapsulation}

  Crate = Node/Go/Python package (sort of)

  åŠŸèƒ½é›†åˆï¼Œä¾‹å¦‚ï¼š\texttt{serde} æä¾›äº†åºåˆ—åŒ–ã€ååºåˆ—åŒ–ç›¸å…³çš„åŸºç¡€è®¾æ–½ã€‚

  \pause
  \vspace{1em}

  Module = Java package (sort of)

  å®ç°å•å…ƒï¼Œâ€œå¯è§æ€§â€œçš„è¾¹ç•Œã€‚ä¾‹å¦‚ï¼š\texttt{serde::ser} åŒ…å«åºåˆ—åŒ– (Serialize) ç›¸å…³çš„å£°æ˜å’Œå®ç°ã€‚

  \pause
  \vspace{1em}

  \begin{minted}{rust}
mod data;
pub use data::{Input, Output};
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Abusing modules}

  \texttt{library/std/src/os/mod.rs:}

  \begin{minted}[breaklines]{rust}
// unix
#[cfg(not(all(
    doc,
    any(
        all(target_arch = "wasm32", not(target_os = "wasi")),
        all(target_vendor = "fortanix", target_env = "sgx")
    )
)))]
#[cfg(target_os = "hermit")]
#[path = "hermit/mod.rs"]
pub mod unix;
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C style preprocessor?}

  \pause

  \only<1-2>{With procedure macro?}
  \only<3>{\sout{With procedure macro?}}
  \begin{minted}{rust}
preprocess!{
  #ifdef PLATFORM_WINDOWS
    // Do something
  #else
    // Do something else
  #endif
}
  \end{minted}

  \pause
  \vspace{1em}

  Please don't.
  
\end{frame}

\begin{frame}
  \frametitle{Polymorphism}

  \begin{itemize}
    \item Composition over Inheritance {\tiny{è®¾è®¡æ¨¡å¼!}}
    \item Trait: æè¿°ä¸€ä¸ªæ¥å£
    \pause
    \item Generic: ä½¿ç”¨ Trait çš„é™æ€æ´¾å‘
    \item Trait Objects: ä½¿ç”¨ Trait çš„åŠ¨æ€æ´¾å‘
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism, Cont.}
  \begin{minted}{rust}
trait Monoid {
  // "Member functions"
  fn product(&self, other: &Self) -> Self;
  // "Static functions"
  fn identity() -> Self;
  fn is_commutative() -> bool;
}

trait Group: Monoid {
  fn inverse(&self) -> Self;
  // Default impl
  fn is_abelian() -> bool {
    return Self::is_commutative();
  }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism, Cont.}

  \begin{minted}{rust}
fn subgroup_by<G>(gen: G) -> Vec<G>
  where G: Group + Eq + Clone
{
  let mut cur = gen.clone();
  let mut result = Vec::new();
  loop {
    result.push(cur.clone());
    cur = cur.product(gen);
    if cur == gen {
      return result;
    }
  }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism, Cont.}

  \begin{minted}{rust}
    let trait_obj: &dyn Group = &group;
  \end{minted}

  \pause
  \vspace{1em}

  VTable with fat pointer

  \pause
  \vspace{1em}
  
  \pause
  \begin{minted}{rust}
  let boxed_fn: Box<dyn Fn(usize) -> usize> =
    Box::new(
        |input: usize| -> usize {
            input * 2
        }
    );
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism... ?}

  \begin{minted}{rust}
trait Trait {}
fn generic_fn<T: Trait + ?Sized>() {
  println!("{}", size_of::<&dyn Trait>()); // -> 16
  println!("{}", size_of::<&T>());         // -> 8
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism... ?}

  \begin{minted}{rust}
trait Trait {}
fn generic_fn<T: Trait + ?Sized>() {
  println!("{}", size_of::<&dyn Trait>()); // -> 16
  println!("{}", size_of::<&T>());         // -> 16
}

fn main() {
  generic_fn::<dyn Trait>();
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Why Traits?}
  
  \pause

  \only<2>{æ²¡æœ‰â€œåŸºç±»å¯¹è±¡â€ï¼Œæ²¡æœ‰â€œè±å½¢ç»§æ‰¿â€ã€‚}
  \only<3->{æ²¡æœ‰â€œåŸºç±»å¯¹è±¡â€ï¼Œ\sout{æ²¡æœ‰â€œè±å½¢ç»§æ‰¿â€ã€‚}}

  \pause

  \begin{minted}{rust}
trait Common {}
trait SpecA {}
trait SpecB {}

impl<T: SpecA> Common for T { }
impl<T: SpecB> Common for T { }
  \end{minted}
  
  \pause
  \vspace{1em}

  Rust \sout{(å°è¯•)} ç¦æ­¢è¿™ä»¶äº‹æƒ…ã€‚
  \begin{itemize}
    \item Orphan rule
    \pause
    \item "Strictly more specified"
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Why Traits (More Solid)}

  \begin{minted}{rust}
trait Common {}
trait SpecA {}
trait SpecB {}

impl<T: SpecA> Common for T { }
impl<T: SpecB + SpecA> Common for T { }
  \end{minted}

  \pause
  \vspace{1em}

  You'll need
  \begin{minted}{rust}
#![feature(specialization)]
  \end{minted}

  See also: RFC 1210: Specialization

  \pause
  \vspace{1em}

  "Chalk"
\end{frame}

\begin{frame}
  \frametitle{impl Trait for (A, B, C)}

  \includegraphics[width=\textwidth]{assets/tuple.png}
\end{frame}

\begin{frame}
  \frametitle{What about array?}

  \includegraphics[width=\textwidth]{assets/array-good.png}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What about array....???}

  \includegraphics[width=\textwidth]{assets/array-bad.png}

  \pause
  \vspace{1em}

  \begin{minted}{rust}
impl<T: const N: usize> Default for [T; N]
  where T: Default;
  \end{minted}

  \pause

  \begin{minted}{rust}
impl<T> Default for [T; 0];
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trait: Operator Overloading}

  \pause

  \begin{minted}{rust}
struct Point(f64, f64);
impl Add for Point {
  type Output = Point;
  fn add(self, rhs: Point) -> Point {
    let Point(sx, sy) = self;
    let Point(rs, ry) = rhs;
    Point(sx + rs, sy + ry)
  }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trait: Operator Overloading, Cont.}
  \begin{minted}{rust}
#[lang = "add"]
pub trait Add<Rhs = Self> {
  // ...
}
  \end{minted}
  \pause

  \begin{minted}{rust}
impl Add for usize {
  type Output = usize;

  #[inline]
  #[rustc_inherit_overflow_checks]
  fn add(self, rhs: usize) -> usize {
    self + rhs
  }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Let's look at \texttt{Box}}

  \begin{minted}{rust}
impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {
  type Target = T;

  fn deref(&self) -> &T {
      &**self
  }
}
  \end{minted}

  \pause
  \vspace{1em}

  Box is a "primitive"
\end{frame}

\begin{frame}[fragile]
  \frametitle{But wait...}

  \begin{minted}{rust}
struct MeowBox<T> {
  ptr: *mut T,
}

impl<T> MeowBox<T> {
  fn new(e: T) -> MeowBox<T> {
    unsafe {
      let space = alloc();
      ptr::write(space, e);
    }
    MeowBox<T> {
      ptr: space
    }
  }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Box is special}

  \begin{minted}{rust}
let old_school: ~usize = ~10;
let now: Box<usize> = Box::new(10);
let now_really: Box<usize> = box 10;
  \end{minted}

  \pause
  \vspace{1em}

  ä½ å¯ä»¥ä» Box ä¸­æŠŠä¸œè¥¿æ‹¿å‡ºæ¥: \texttt{DerefMove}(rfcs\#997)

  \begin{minted}{rust}
struct NoClone(usize);
let boxed = Box::new(NoClone(0));
let inner = *boxed; // Box is invalid now
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{But there's a cost\dots}

  \begin{minted}{rust}
let large = Box::new([0; 1000000]);
  \end{minted}

  \pause
  \vspace{1em}
  Guaranteed RVO? Not yet.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Detour: Optimization}
  \begin{minted}{rust}
fn main() {
  (|| (loop {}))()
}
  \end{minted}
  
  \pause
  \vspace{1em}

  Illegal Instruction (\#28728)

  "Forward progress guarantee"

  \pause

  LLVM 12 \& cranelift \& gccrs
\end{frame}

\begin{frame}[fragile]
  \frametitle{"But that's LLVM's fault!"}

  \begin{minted}{rust}
enum Option<T> {
  None, Some(T),
}
  \end{minted}
  \begin{minted}{rust}
size_of::<Option<bool>>();
size_of::<Option<&T>>();
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{"But that's LLVM's fault!"}

  \begin{minted}{rust}
enum Option<T> {
  None, Some(T),
}
  \end{minted}
  \begin{minted}{rust}
size_of::<Option<bool>>(); // 1
size_of::<Option<&T>>();   // 8
  \end{minted}

  \pause

  \begin{minted}{rust}
size_of::<Option<MaybeUninit<bool>>>(); // 2
size_of::<Option<MaybeUninit<&T>>>();   // 16
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Borrow checker}

  æ ¸å¿ƒç›®æ ‡ï¼š
  \begin{itemize}
    \item è¯»ä¸äº†éæ³•å†…å­˜ (Uninitialized, Use after freed)
    \item æ¯”è¾ƒéš¾ Race (ä¸€æ®µä»£ç ã€ä¸€ä¸ªçº¿ç¨‹åœ¨è¯»ï¼Œå¦å¤–ä¸€æ®µä»£ç ã€ä¸€ä¸ªçº¿ç¨‹åœ¨å†™ï¼‰
  \end{itemize}

  \pause
  \vspace{1em}

  Lifetime!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lifetime}

  \begin{minted}{rust}
let mut slot: Option<&usize> = None;
{
  let data = 10usize;
  slot = Some(&data); // Error!
}
println!("{}", slot.unwrap());
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lifetime, Cont.}

  \begin{minted}{rust}
fn main() {
  let on_stack = 10usize;
  thread::spawn(|| { // Error!
    println!("{}", on_stack);
  });
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{But if we really need...}

  \pause

  Thread guards:

  \begin{minted}{rust}
fn main() {
  let on_stack = 10usize;
  let guard = thread::scoped(|| {
    println!("{}", on_stack);
  });

  // guard impls Drop (dtor)
  // Thread joins here
}
    
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Oops}

  \begin{figure}
    \includegraphics[width=\textwidth]{assets/thread.png}
    \caption{ğŸ§µ}
  \end{figure}

  \begin{minted}{rust}
struct Evil<'a> {
  link: RefCell<Option<Rc<Rc<Evil<'a>>>>>,
  arm: thread::JoinGuard<'a, ()>
}
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{rfcs\#1066}
  \texttt{mem::forget} å»æ‰äº† \texttt{unsafe}.

  \pause

  \begin{itemize}
    \item \texttt{Drain} éœ€è¦ç¡®ä¿åªç§»å‡ºäº†ä¸€éƒ¨åˆ†æ—¶ä¸ä¼šè®¿é—®éæ³•å†…å­˜ã€‚
    \item \texttt{Arc} éœ€è¦è€ƒè™‘æº¢å‡ºã€‚
    \item \texttt{thread::scoped} è¢«å®Œå…¨åˆ é™¤äº†ã€‚
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Last but not least...}

  https://turbo.fish

  \pause

  \textbf{Bastion of The Turbofish}
  https://github.com/rust-lang/rust/blob/master/src/test/ui/bastion-of-the-turbofish.rs
\end{frame}

\begin{frame}
  \frametitle{If we got time...}

  \begin{itemize}
    \item ä¸ºä»€ä¹ˆæ–¹æ³•é‡Œå…è®¸ \texttt{self: Pin<Self>}
    \item ä¸ºä»€ä¹ˆç°åœ¨ Rust æ ‡å‡†åº“é‡Œçš„ HashTable å®ç°ï¼Œåœ¨æŸ¥æ‰¾-æ’å…¥çš„æ—¶å€™éœ€è¦çº¿æ€§æ‰«æä¸¤æ¬¡ï¼Ÿ
    \item ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥å®ç° Eqï¼Ÿ
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{That's All!}

  \begin{center}
    \includegraphics[width=.5\textwidth]{assets/look.png}

    Question time!
  \end{center}
\end{frame}
\end{document}
